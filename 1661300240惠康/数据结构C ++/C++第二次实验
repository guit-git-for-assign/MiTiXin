 
的#include <iostream的>
using namespace std; 
typedef int DataType;
#define ERROR NULL
 //定义节点类型
struct Node
{ 上市： 
		数据类型数据; //数据域
	    节点*下一个; //指针域
}; 
//构建一个单链表类
class LinkList
{   
	上市：
		链表（）; //构建一个单链表;    
		〜链表（）; //销毁一个单链表;    
		void CreateLinkList（int n）; //创建一个单链表   
		void TravalLinkList（）; //遍历线性表   
		int GetLength（）; //获取线性表长度 
		bool IsEmpty（）; //判断单链表是否为空
    	             节点*查找（数据类型数据）; //查找节点  
	    
		void Insert（DataType数据）; //在指定位置插入指定元素  
		void DeleteElemAtEnd（）; //在尾部删除元素
		void DeleteAll（）; //删除所有数据  
		void DeleteElemAtPoint（DataType data）; //删除指定的数据    
		void DeleteElemAtHead（）; //在头部删除节点
	私人的：  
		节点*头; //头结点
}; 
//初始化单链表
链表::链表（） 
{ 
	head = new Node; 
    head-> data = 0; //将头结点的数据域定义为0
    head-> next = NULL; //头结点的下一个定义为NULL
} 
//销毁单链表
链表::〜链表（）
{  
	节点* q = head-> next; //定义q指向空白头点的结下一个
	while（q！= NULL）//当指针的地址不为空时
	{  
		 head-> next = q-> next; //让q所指向的结点从链表中脱离出来，并保持原链表的链不断开
		 删除q; //释放从链表中脱离出来的结点的空间
		 Q =头戴式>下; // q之前指向的结点已被删除，现在需要重新给q赋值
    }
	删除头; //其余结点已被删完，最后删除空白头结点
} 
//创建一个单链表
void LinkList :: CreateLinkList（int n）
{  
	Node * pnew，* ptemp; 
    ptemp = head; 

    if（n <0）
    {//当输入的值有误时，处理异常      
        cout <<“输入的节点个数有误”<< endl;    
        出口（EXIT_FAILURE）; 
    }   
    for（int i = 0; i <n; i ++）
     {//将值一个一个插入单链表中pnew = new Node;        
        cout <<“请输入第”<< i + 1 <<“个值：”; 
		pnew = new Node; 
        cin >> pnew-> data;  
        pnew-> next = NULL; //新节点的下一个地址为NULL  
        ptemp-> next = pnew; //当前结点的下一个地址设为新节点 
        ptemp = pnew; //将当前结点设为新节点    
    }
} 
//遍历单链表
void LinkList :: TravalLinkList（）
{
    if（head == NULL || head-> next == NULL）
     {cout <<“链表为空表”<< endl; }   
    节点* p =头; //另指针指向头结点    
    while（p-> next！= NULL）//当指针的下一个地址不为空时，循环输出p的数据域   
    {
		p = p-> next; // p指向p的下一个地址     
        cout << p-> data <<“|”; 
	}
	cout << endl;
} 
//获取单链表的长度
int LinkList :: GetLength（）
{  
	int count = 0; //定义计数计数
	节点* p = head-> next; //定义p指向头结点
	while（p！= NULL）//当指针的下一个地址不为空时，count + 1  
	{  
		计数++; 
        p = p-> next; // p指向p的下一个地址
    }
    返回计数; //返回计数的数据
} 
//判断单链表是否为空
bool LinkList :: IsEmpty（）
{  
	if（head-> next == NULL）
		返回true;
	其他
		返回false;
} 
//查找节点
Node * LinkList :: Find（DataType数据）
{
	节点* p = head-> next;    
	if（p == NULL）{//当为空表时，报异常      
		cout <<“此链表为空链表”<< endl;
		返回ERROR;
	}   
	其他
    {
		while（p！= NULL）//循环每一个节点      
		{
			if（p-> data == data）
			{   
				返回p; //返回指针域
			}           
			p = p-> next;        
		}       
		返回NULL; //未查询到结
    }

} 

//在指定位置插入指定元素
void LinkList :: Insert（DataType数据）
{  
		Node * pointer = new Node; //创建一个新的节点       
		指针 - >数据=数据; //定义数据域 
		节点* p =头; //创建一个指针指向头结点       
		int i = 1; 
	     
		while（GetLength（）> = i）//遍历到指定的位置   
        {
			p = p-> next;
		
	 如果（对 - >数据> =指针 - >数据）
		{
		 int t=p->data;
		 p->data =pointer->data;
		 pointer->data=t;}
         i++;        
		}   
		pointer->next = p->next; //将新节点插入到指定位置      
		p->next = pointer;
	

} 
//在尾部删除元素
void LinkList::DeleteElemAtEnd()
{   
	Node * p = head; //创建一个指针指向头结点    
	Node * ptemp = NULL; //创建一个占位节点
	if (p->next == NULL)
	{ //判断链表是否为空       
		cout << "单链表空" << endl; 
	}
     else   
	{
		while (p->next != NULL) //循环到尾部的前一个
		{
			ptemp = p; //将ptemp指向尾部的前一个节点         
			p = p->next; //p指向最后一个节点
		}       
		delete p; //删除尾部节点        
		p = NULL;       
		ptemp->next = NULL; 
	}
}
//删除所有数据
void LinkList::DeleteAll()
{  
	Node * p = head->next;  
	Node * ptemp = new Node;    
	while (p != NULL) //在头结点的下一个节点逐个删除节点
    {  
		ptemp = p;      
		p = p->next;        
		head->next = p; 
	    ptemp->next = NULL;     
		delete ptemp;   
	}   
	head->next = NULL; //头结点的下一个节点指向NULL
} 
//删除指定的数据
void LinkList::DeleteElemAtPoint(DataType data)
{  
	Node * ptemp = Find(data); //查找到指定数据的节点位置    
	if (ptemp == head->next) 
	{ //判断是不是头结点的下一个节点，如果是就从头部删了它              
		DeleteElemAtHead();
    }   
	else    
	{   
		Node * p = head; //p指向头结点 
		while (p->next != ptemp) //p循环到指定位置的前一个节点      
		{
			p = p->next;    
		}       
		p->next = ptemp->next; //删除指定位置的节点    
		delete ptemp;       
		ptemp = NULL;    
	} 
}
//在头部删除节点
void LinkList::DeleteElemAtHead()
{  
	Node * p = head;
	if (p == NULL || p->next == NULL)
	{ //判断是否为空表，报异常   
        cout << "该链表为空表" << endl;   
	}   
	else   
	{   
		Node * ptemp = NULL; //创建一个占位节点    
		p = p->next;        
		ptemp = p->next; //将头结点的下下个节点指向占位节点  
		delete p; //删除头结点的下一个节点    
		p = NULL;       
		head->next = ptemp; //更换头结点的指针域 
	}
}
//测试函数
int main()
{   
	LinkList l;
    int i;
	do {   
		cout << "*******************\n1.创建单链表\n2.遍历单链表\n3.获取单链表的长度\n4.判断单链表是否为空\n5.查找节点\n";  
		cout << "7.插入元素\n9.在尾部删除元素\n10.删除所有元素\n11.删除指定元素\n12.在头部删除元素\n0.退出\n*******************"<< endl;

		cout << "请输入要执行的操作: ";  
		cin >> i;       
		switch (i)  {
			case 1:   
				   int n;      
				   cout << "请输入单链表的长度: ";
				   cin >> n;   
				   l.CreateLinkList(n);            
				   break;      
			case 2:         
				   l.TravalLinkList();     
				   break;      
			case 3:         
				   cout << "该单链表的长度为" << l.GetLength() << endl;    
				   break;      
			case 4:         
				   if (l.IsEmpty() == 1)   
						cout << "该单链表是空表" << endl;          
				   else            
					    cout << "该单链表不是空表" << endl;             
				   break; 
			case 5: 
				   DataType data;      
				   cout << "请输入要查找节点的值: ";     
	               cin >> data;  
				   if(l.Find(data))    
						cout << "链表中存在该节点"  << endl; 
				   else      
						cout << "链表中找不到该节点"  << endl;   
				   break;      
			case 7:         
				   DataType pointData;          
				   cout << "请输入要插入的数据: ";      
				   cin >> pointData;       
				   l.Insert(pointData);      
				   break;      
			case 9:     
				   l.DeleteElemAtEnd();        
				   break;      
			case 10:        
				   l.DeleteAll();          
				   break;      
			case 11:        
				   DataType pointDeleteData;       
				   cout <<“请输入要删除的数据：”;  
				   cin >> pointDeleteData; 
				   l.DeleteElemAtPoint（pointDeleteData）;            
				   打破;      
			案例12：        
				   l.DeleteElemAtHead（）;           
				   打破;      
			默认值：break;        
		} //结束开关
	} while（i！= 0）; //结束做
	系统（ “暂停”）; 
	返回0;
}

